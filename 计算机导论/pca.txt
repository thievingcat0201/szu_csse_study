reshaped_faces=[];%%创建一个矩阵
for i=1:99%循环多少个人
for j=1:20%每人多少个样本
if(i<10)%输入图片自动转化为矩阵
a=imread(strcat('C:\Users\27419\Desktop\pca\AR_Gray_50by40\AR00',num2str(i),'-',num2str(j),'.tif'));%num2str（）数组将数字转化为字符，构建图像地址
else
a=imread(strcat('C:\Users\27419\Desktop\pca\AR_Gray_50by40\AR0',num2str(i),'-',num2str(j),'.tif'));
end%结束选择循环
b=reshape(a,2000,1);%创建数组将每一张照片对应矩阵拉成列，2000为像素
b=double(b);%增大存储量
reshaped_faces=[reshaped_faces,b];%将循环中的b全部输入新矩阵中，每一列为一张图片
end
end
test=[];%定义一个测试数据组
train=[];%定义一个训练数据组
for i=0:99
test=[test 10*i+1:10*i+6];%提取每一张人脸前六张作为测试
train=[train 10*i+7:10*i+14];%提取每一张人脸的后14张作为训练
end
train_data=reshaped_faces(:,train);%将每张人脸的train数列合并为一个矩阵，以便开始降维
test_data=reshaped_faces(:,test);
 


%%求均值和中心化减去平均脸
mean_face=mean(train_data,2);%求训练脸的平均mean函数
centered_face=(train_data-mean_face);%每一张脸均减去平均脸



%协方差特征值等准备进行降维（直接用cov函数）
cov_matrix=centered_face*centered_face';%求协方差
[eigen_vectors,dianogol_matrix]=eig(cov_matrix);%特征向量转化为对角矩阵，eig函数的用法第一个为特征向量，第二个为特征值（以矩阵方式返回）


eigen_values=diag(dianogol_matrix);%从对角阵获取特征值diag函数获取矩阵对角元素
[sorted_eigen_values,index]=sort(eigen_values,'descend');%sort函数 按降序对特征值进行排序（按列排序）
sorted_eigen_vectors=eigen_vectors(:,index);%排序后特征值对应的特征向量
all_eigen_faces=sorted_eigen_vectors;%获取所有特征脸的特征向量



%重构（数据降维，还原图片矩阵）

single_face = centered_face(:,1);%取出第一个人脸进行重构
index = 1;%索引1
for dimensionality=20:20:160%以20维度开始向160逐渐增加
     eigen_faces = all_eigen_faces(:,1:dimensionality);

rebuild_face = eigen_faces * (eigen_faces' * single_face) + mean_face;%在不同维度下重构人脸
        subplot(2, 4, index); %两行四列，subplot函数创建坐标区
        index = index + 1;%依次增大索引，不同照片
        fig = show_face(rebuild_face);%展示照片
        title(sprintf("dimensionality=%d", dimensionality));%明晰该照片的维度    
        if (dimensionality == 160)
            waitfor(fig);%阻止程序的运行
        end%if选择函数的结束
end%循环结束，第一张照片的测试完成

%人脸识别

index = 1;       
Y = [];
% KNN
for k=1:6

    for i=10:10:160
   eigen_faces = all_eigen_faces(:,1:i);
    % 测试、训练数据降维
    projected_train_data = eigen_faces' * (train_data - mean_face);
    projected_test_data = eigen_faces' * (test_data - mean_face);
        % 用于保存最小的k个值的矩阵
        % 用于保存最小k个值对应的人标签的矩阵
        minimun_k_values = zeros(k,1);
        label_of_minimun_k_values = zeros(k,1);

        % 测试脸的数量
        test_face_number = size(projected_test_data, 2);

        % 识别正确数量
        correct_predict_number = 0;

        % 遍历每一个待测试人脸
        for each_test_face_index = 1:test_face_number

            each_test_face = projected_test_data(:,each_test_face_index);

            % 先把k个值填满，避免在迭代中反复判断
            for each_train_face_index = 1:k
                minimun_k_values(each_train_face_index,1) = norm(each_test_face - projected_train_data(:,each_train_face_index));
                label_of_minimun_k_values(each_train_face_index,1) = floor((train_data_index(1,each_train_face_index) - 1) / 10) + 1;
            end

            % 找出k个值中最大值及其下标
            [max_value, index_of_max_value] = max(minimun_k_values);

            % 计算与剩余每一个已知人脸的距离
            for each_train_face_index = k+1:size(projected_train_data,2)

                % 计算距离
                distance = norm(each_test_face - projected_train_data(:,each_train_face_index));

                % 遇到更小的距离就更新距离和标签
                if (distance < max_value)
                    minimun_k_values(index_of_max_value,1) = distance;
                    label_of_minimun_k_values(index_of_max_value,1) = floor((train_data_index(1,each_train_face_index) - 1) / 10) + 1;
                    [max_value, index_of_max_value] = max(minimun_k_values);
                end
            end

            % 最终得到距离最小的k个值以及对应的标签
            % 取出出现次数最多的值，为预测的人脸标签
            predict_label = mode(label_of_minimun_k_values);
            real_label = floor((test_data_index(1,each_test_face_index) - 1) / 10)+1;

            if (predict_label == real_label)
                correct_predict_number = correct_predict_number + 1;
            end
        end
        % 单次识别率
        correct_rate = correct_predict_number/test_face_number;
        Y = [Y correct_rate];
    end
end

% 求不同k值不同维度下的人脸识别率及对k的平均识别率
Y = reshape(Y,k,16);
waitfor(waterfall(Y));
avg_correct_rate=mean(Y);
waitfor(plot(avg_correct_rate));